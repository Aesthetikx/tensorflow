# Generated by `rake generate_ops`
module TensorFlow
  module GeneratedOps
    def abs(x)
      execute("Abs", [x])
    end

    def acos(x)
      execute("Acos", [x])
    end

    def acosh(x)
      execute("Acosh", [x])
    end

    def add(x, y)
      execute("Add", [x, y])
    end

    def add_n(inputs)
      execute("AddN", [inputs])
    end

    def approximate_equal(x, y, tolerance: nil)
      execute("ApproximateEqual", [x, y], tolerance: tolerance)
    end

    def as_string(input, precision: nil, scientific: nil, shortest: nil, width: nil, fill: nil)
      execute("AsString", [input], precision: precision, scientific: scientific, shortest: shortest, width: width, fill: fill)
    end

    def asin(x)
      execute("Asin", [x])
    end

    def asinh(x)
      execute("Asinh", [x])
    end

    def assign_add_variable_op(resource, value, dtype: nil)
      execute("AssignAddVariableOp", [resource, value], dtype: dtype)
    end

    def assign_sub_variable_op(resource, value, dtype: nil)
      execute("AssignSubVariableOp", [resource, value], dtype: dtype)
    end

    def assign_variable_op(resource, value, dtype: nil)
      execute("AssignVariableOp", [resource, value], dtype: dtype)
    end

    def atan(x)
      execute("Atan", [x])
    end

    def atan2(y, x)
      execute("Atan2", [y, x])
    end

    def atanh(x)
      execute("Atanh", [x])
    end

    def batch_mat_mul(x, y, adj_x: nil, adj_y: nil)
      execute("BatchMatMul", [x, y], adj_x: adj_x, adj_y: adj_y)
    end

    def batch_to_space(input, crops, block_size: nil)
      execute("BatchToSpace", [input, crops], block_size: block_size)
    end

    def bessel_i0e(x)
      execute("BesselI0e", [x])
    end

    def bessel_i1e(x)
      execute("BesselI1e", [x])
    end

    def bitcast(input, type: nil)
      execute("Bitcast", [input], type: type)
    end

    def bitwise_and(x, y)
      execute("BitwiseAnd", [x, y])
    end

    def bitwise_or(x, y)
      execute("BitwiseOr", [x, y])
    end

    def bitwise_xor(x, y)
      execute("BitwiseXor", [x, y])
    end

    def broadcast_to(input, shape)
      execute("BroadcastTo", [input, shape])
    end

    def case(branch_index, input, branches: nil, output_shapes: nil)
      execute("Case", [branch_index, input], branches: branches, output_shapes: output_shapes)
    end

    def cast(x)
      execute("Cast", [x])
    end

    def ceil(x)
      execute("Ceil", [x])
    end

    def clip_by_value(t, clip_value_min, clip_value_max)
      execute("ClipByValue", [t, clip_value_min, clip_value_max])
    end

    def complex(real, imag)
      execute("Complex", [real, imag])
    end

    def complex_abs(x)
      execute("ComplexAbs", [x])
    end

    def concat(concat_dim, values)
      execute("Concat", [concat_dim, values])
    end

    def conjugate_transpose(x, perm)
      execute("ConjugateTranspose", [x, perm])
    end

    def cos(x)
      execute("Cos", [x])
    end

    def cosh(x)
      execute("Cosh", [x])
    end

    def cumprod(x, axis, exclusive: nil, reverse: nil)
      execute("Cumprod", [x, axis], exclusive: exclusive, reverse: reverse)
    end

    def cumsum(x, axis, exclusive: nil, reverse: nil)
      execute("Cumsum", [x, axis], exclusive: exclusive, reverse: reverse)
    end

    def data_format_dim_map(x, src_format: nil, dst_format: nil)
      execute("DataFormatDimMap", [x], src_format: src_format, dst_format: dst_format)
    end

    def data_format_vec_permute(x, src_format: nil, dst_format: nil)
      execute("DataFormatVecPermute", [x], src_format: src_format, dst_format: dst_format)
    end

    def deep_copy(x)
      execute("DeepCopy", [x])
    end

    def digamma(x)
      execute("Digamma", [x])
    end

    def divide(x, y)
      execute("Div", [x, y])
    end

    def div_no_nan(x, y)
      execute("DivNoNan", [x, y])
    end

    def dynamic_partition(data, partitions, num_partitions: nil)
      execute("DynamicPartition", [data, partitions], num_partitions: num_partitions)
    end

    def dynamic_stitch(indices, data)
      execute("DynamicStitch", [indices, data])
    end

    def edit_distance(hypothesis_indices, hypothesis_values, hypothesis_shape, truth_indices, truth_values, truth_shape, normalize: nil)
      execute("EditDistance", [hypothesis_indices, hypothesis_values, hypothesis_shape, truth_indices, truth_values, truth_shape], normalize: normalize)
    end

    def ensure_shape(input, shape: nil)
      execute("EnsureShape", [input], shape: shape)
    end

    def equal(x, y)
      execute("Equal", [x, y])
    end

    def erf(x)
      execute("Erf", [x])
    end

    def erfc(x)
      execute("Erfc", [x])
    end

    def exp(x)
      execute("Exp", [x])
    end

    def expand_dims(input, dim)
      execute("ExpandDims", [input, dim])
    end

    def expm1(x)
      execute("Expm1", [x])
    end

    def extract_volume_patches(input, ksizes: nil, strides: nil, padding: nil)
      execute("ExtractVolumePatches", [input], ksizes: ksizes, strides: strides, padding: padding)
    end

    def fill(dims, value, index_type: nil)
      execute("Fill", [dims, value], index_type: index_type)
    end

    def fingerprint(data, method)
      execute("Fingerprint", [data, method])
    end

    def floor(x)
      execute("Floor", [x])
    end

    def floordiv(x, y)
      execute("FloorDiv", [x, y])
    end

    def floormod(x, y)
      execute("FloorMod", [x, y])
    end

    def fused_batch_norm(x, scale, offset, mean, variance, epsilon: nil, data_format: nil, is_training: nil)
      execute("FusedBatchNorm", [x, scale, offset, mean, variance], epsilon: epsilon, data_format: data_format, is_training: is_training)
    end

    def gather(params, indices, validate_indices: nil)
      execute("Gather", [params, indices], validate_indices: validate_indices)
    end

    def gather_nd(params, indices)
      execute("GatherNd", [params, indices])
    end

    def greater(x, y)
      execute("Greater", [x, y])
    end

    def greater_equal(x, y)
      execute("GreaterEqual", [x, y])
    end

    def guarantee_const(input)
      execute("GuaranteeConst", [input])
    end

    def histogram_fixed_width(values, value_range, nbins, dtype: nil)
      execute("HistogramFixedWidth", [values, value_range, nbins], dtype: dtype)
    end

    def identity(input)
      execute("Identity", [input])
    end

    def identity_n(input)
      execute("IdentityN", [input])
    end

    def inplace_add(x, i, v)
      execute("InplaceAdd", [x, i, v])
    end

    def inplace_sub(x, i, v)
      execute("InplaceSub", [x, i, v])
    end

    def inplace_update(x, i, v)
      execute("InplaceUpdate", [x, i, v])
    end

    def inv(x)
      execute("Inv", [x])
    end

    def invert(x)
      execute("Invert", [x])
    end

    def invert_permutation(x)
      execute("InvertPermutation", [x])
    end

    def is_finite(x)
      execute("IsFinite", [x])
    end

    def is_inf(x)
      execute("IsInf", [x])
    end

    def is_nan(x)
      execute("IsNan", [x])
    end

    def left_shift(x, y)
      execute("LeftShift", [x, y])
    end

    def less(x, y)
      execute("Less", [x, y])
    end

    def less_equal(x, y)
      execute("LessEqual", [x, y])
    end

    def lgamma(x)
      execute("Lgamma", [x])
    end

    def list_diff(x, y, out_idx: nil)
      execute("ListDiff", [x, y], out_idx: out_idx)
    end

    def log(x)
      execute("Log", [x])
    end

    def log1p(x)
      execute("Log1p", [x])
    end

    def logical_and(x, y)
      execute("LogicalAnd", [x, y])
    end

    def logical_not(x)
      execute("LogicalNot", [x])
    end

    def logical_or(x, y)
      execute("LogicalOr", [x, y])
    end

    def matrix_set_diag(input, diagonal)
      execute("MatrixSetDiag", [input, diagonal])
    end

    def matrix_square_root(input)
      execute("MatrixSquareRoot", [input])
    end

    def maximum(x, y)
      execute("Maximum", [x, y])
    end

    def minimum(x, y)
      execute("Minimum", [x, y])
    end

    def mod(x, y)
      execute("Mod", [x, y])
    end

    def multiply(x, y)
      execute("Mul", [x, y])
    end

    def mul_no_nan(x, y)
      execute("MulNoNan", [x, y])
    end

    def neg(x)
      execute("Neg", [x])
    end

    def no_op
      execute("NoOp", [])
    end

    def not_equal(x, y)
      execute("NotEqual", [x, y])
    end

    def one_hot(indices, depth, on_value, off_value, axis: nil)
      execute("OneHot", [indices, depth, on_value, off_value], axis: axis)
    end

    def ones_like(x)
      execute("OnesLike", [x])
    end

    def pad(input, paddings)
      execute("Pad", [input, paddings])
    end

    def population_count(x)
      execute("PopulationCount", [x])
    end

    def pow(x, y)
      execute("Pow", [x, y])
    end

    def print(input, data, message: nil, first_n: nil, summarize: nil)
      execute("Print", [input, data], message: message, first_n: first_n, summarize: summarize)
    end

    def quantized_add(x, y, min_x, max_x, min_y, max_y)
      execute("QuantizedAdd", [x, y, min_x, max_x, min_y, max_y])
    end

    def quantized_instance_norm(x, x_min, x_max, output_range_given: nil, given_y_min: nil, given_y_max: nil, variance_epsilon: nil, min_separation: nil)
      execute("QuantizedInstanceNorm", [x, x_min, x_max], output_range_given: output_range_given, given_y_min: given_y_min, given_y_max: given_y_max, variance_epsilon: variance_epsilon, min_separation: min_separation)
    end

    def quantized_mul(x, y, min_x, max_x, min_y, max_y)
      execute("QuantizedMul", [x, y, min_x, max_x, min_y, max_y])
    end

    def range(start, limit, delta)
      execute("Range", [start, limit, delta])
    end

    def rank(input)
      execute("Rank", [input])
    end

    def read_variable_op(resource, dtype: nil)
      execute("ReadVariableOp", [resource], dtype: dtype)
    end

    def real_div(x, y)
      execute("RealDiv", [x, y])
    end

    def reciprocal(x)
      execute("Reciprocal", [x])
    end

    def reshape(tensor, shape)
      execute("Reshape", [tensor, shape])
    end

    def reverse(tensor, dims)
      execute("Reverse", [tensor, dims])
    end

    def reverse_sequence(input, seq_lengths, seq_dim: nil, batch_dim: nil)
      execute("ReverseSequence", [input, seq_lengths], seq_dim: seq_dim, batch_dim: batch_dim)
    end

    def right_shift(x, y)
      execute("RightShift", [x, y])
    end

    def rint(x)
      execute("Rint", [x])
    end

    def roll(input, shift, axis)
      execute("Roll", [input, shift, axis])
    end

    def round(x)
      execute("Round", [x])
    end

    def rsqrt(x)
      execute("Rsqrt", [x])
    end

    def scatter_nd(indices, updates, shape)
      execute("ScatterNd", [indices, updates, shape])
    end

    def shape(input, out_type: nil)
      execute("Shape", [input], out_type: out_type)
    end

    def shape_n(input, out_type: nil)
      execute("ShapeN", [input], out_type: out_type)
    end

    def sigmoid(x)
      execute("Sigmoid", [x])
    end

    def sign(x)
      execute("Sign", [x])
    end

    def sin(x)
      execute("Sin", [x])
    end

    def sinh(x)
      execute("Sinh", [x])
    end

    def size(input, out_type: nil)
      execute("Size", [input], out_type: out_type)
    end

    def slice(input, begin_, size)
      execute("Slice", [input, begin_, size])
    end

    def space_to_batch(input, paddings, block_size: nil)
      execute("SpaceToBatch", [input, paddings], block_size: block_size)
    end

    def space_to_batch_nd(input, block_shape, paddings)
      execute("SpaceToBatchND", [input, block_shape, paddings])
    end

    def split(split_dim, value, num_split: nil)
      execute("Split", [split_dim, value], num_split: num_split)
    end

    def sqrt(x)
      execute("Sqrt", [x])
    end

    def square(x)
      execute("Square", [x])
    end

    def squared_difference(x, y)
      execute("SquaredDifference", [x, y])
    end

    def squeeze(input, squeeze_dims: nil)
      execute("Squeeze", [input], squeeze_dims: squeeze_dims)
    end

    def stack(elem_type: nil, stack_name: nil)
      execute("Stack", [], elem_type: elem_type, stack_name: stack_name)
    end

    def stop_gradient(input)
      execute("StopGradient", [input])
    end

    def strided_slice(input, begin_, end_, strides, begin_mask: nil, end_mask: nil, ellipsis_mask: nil, new_axis_mask: nil, shrink_axis_mask: nil)
      execute("StridedSlice", [input, begin_, end_, strides], begin_mask: begin_mask, end_mask: end_mask, ellipsis_mask: ellipsis_mask, new_axis_mask: new_axis_mask, shrink_axis_mask: shrink_axis_mask)
    end

    def subtract(x, y)
      execute("Sub", [x, y])
    end

    def tan(x)
      execute("Tan", [x])
    end

    def tanh(x)
      execute("Tanh", [x])
    end

    def tile(input, multiples)
      execute("Tile", [input, multiples])
    end

    def timestamp
      execute("Timestamp", [])
    end

    def transpose(x, perm)
      execute("Transpose", [x, perm])
    end

    def truncate_div(x, y)
      execute("TruncateDiv", [x, y])
    end

    def truncate_mod(x, y)
      execute("TruncateMod", [x, y])
    end

    def unique(x, out_idx: nil)
      execute("Unique", [x], out_idx: out_idx)
    end

    def unique_with_counts(x, out_idx: nil)
      execute("UniqueWithCounts", [x], out_idx: out_idx)
    end

    def unravel_index(indices, dims)
      execute("UnravelIndex", [indices, dims])
    end

    def var_handle_op(container: nil, shared_name: nil, dtype: nil, shape: nil)
      execute("VarHandleOp", [], container: container, shared_name: shared_name, dtype: dtype, shape: shape)
    end

    def var_is_initialized_op(resource)
      execute("VarIsInitializedOp", [resource])
    end

    def where(input)
      execute("Where", [input])
    end

    def xdivy(x, y)
      execute("Xdivy", [x, y])
    end

    def xlogy(x, y)
      execute("Xlogy", [x, y])
    end

    def zeros_like(x)
      execute("ZerosLike", [x])
    end

    def zeta(x, q)
      execute("Zeta", [x, q])
    end
  end
end
